<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>墨池海贼团：玄月传 (Inkwell Pirates: Legend of Xuan Yue)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
        }
        #game-container {
            position: relative;
            border: 4px solid #2d2d44;
            border-radius: 8px;
            box-shadow: 
                0 0 40px rgba(0,0,0,0.8),
                inset 0 0 20px rgba(255,255,255,0.05);
        }
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 15px 20px;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }
        .char-status {
            flex: 1;
            max-width: 320px;
        }
        .char-status.p2 {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        .name {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px #000, 0 0 10px rgba(0,0,0,0.8);
            margin-bottom: 4px;
            letter-spacing: 1px;
        }
        .bar-container {
            position: relative;
            width: 100%;
            height: 22px;
            background: linear-gradient(180deg, #1a1a1a 0%, #333 100%);
            border: 2px solid #000;
            border-radius: 3px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        .hp-fill {
            height: 100%;
            background: linear-gradient(180deg, #ff6b6b 0%, #c0392b 50%, #8b0000 100%);
            transition: width 0.15s ease-out;
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.2);
        }
        .hp-fill.p1 {
            background: linear-gradient(180deg, #ffd93d 0%, #ff9f1c 50%, #e67e22 100%);
        }
        .mp-container {
            width: 70%;
            height: 12px;
            margin-top: 4px;
            background: linear-gradient(180deg, #1a1a1a 0%, #222 100%);
            border: 1px solid #000;
            border-radius: 2px;
            overflow: hidden;
        }
        .mp-fill {
            height: 100%;
            background: linear-gradient(180deg, #74b9ff 0%, #0984e3 50%, #0652DD 100%);
            transition: width 0.1s;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.3);
        }
        .controls-hint {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            text-shadow: 1px 1px 2px #000;
            white-space: nowrap;
        }
        .combo-display {
            position: absolute;
            top: 80px;
            font-size: 28px;
            font-weight: bold;
            color: #ffd93d;
            text-shadow: 3px 3px 6px #000, 0 0 20px rgba(255,217,61,0.5);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .combo-display.p1 { left: 30px; }
        .combo-display.p2 { right: 30px; }
        .combo-display.active { opacity: 1; }
        
        /* 加载提示 */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="960" height="540"></canvas>
    <div id="ui-layer">
        <div class="hud-top">
            <div class="char-status p1">
                <div class="name">玄月 • 阮</div>
                <div class="bar-container"><div class="hp-fill p1" id="p1-hp"></div></div>
                <div class="mp-container"><div class="mp-fill" id="p1-mp"></div></div>
            </div>
            <div class="char-status p2">
                <div class="name">里奥 (CPU)</div>
                <div class="bar-container"><div class="hp-fill" id="p2-hp"></div></div>
            </div>
        </div>
        <div class="combo-display p1" id="combo-p1"></div>
        <div class="combo-display p2" id="combo-p2"></div>
        <div class="controls-hint">
            [A/D] 移动 | [K] 跳跃(二段) | [L] 瞬步 | [J] 普攻连招 | [U] 泼墨·鸦杀 | [I] 千机·龙舌 | [O] 墨皇·崩界
        </div>
    </div>
    <div id="loading">加载中...</div>
</div>

<script>
/**
 * 墨池海贼团：玄月传 - 使用精灵图的格斗游戏
 */

// ============== 配置常量 ==============
const CONFIG = {
    CANVAS_WIDTH: 960,
    CANVAS_HEIGHT: 540,
    GRAVITY: 0.65,
    FRICTION: 0.88,
    GROUND_Y: 480,
    
    // 玩家属性
    PLAYER: {
        SPEED: 6,
        JUMP_FORCE: -14,
        DASH_SPEED: 18,
        DASH_DURATION: 12,
        DASH_COOLDOWN: 25,
        MAX_HP: 100,
        MAX_MP: 100,
        MP_REGEN: 0.08
    },
    
    // 敌人属性
    ENEMY: {
        SPEED: 2.5,
        MAX_HP: 100,
        ATTACK_RANGE: 80,
        AGGRO_RANGE: 400
    }
};

// 状态枚举
const STATE = {
    IDLE: 'idle',
    RUN: 'run',
    JUMP: 'jump',
    ATTACK: 'attack',
    SKILL_U: 'skill_u',
    SKILL_I: 'skill_i',
    SKILL_O: 'skill_o',
    DASH: 'dash',
    HIT: 'hit',
    DEAD: 'dead'
};

// ============== 精灵图数据 (Base64) ==============
// 由于图片是用户提供的，这里我们需要从外部加载
// 为了演示，我们先用占位符，实际使用时替换为真实图片路径

const SPRITE_PATHS = {
    idle: 'sprites/idle.png',      // 站立
    run: 'sprites/run.png',        // 跑步/冲刺
    skill_u: 'sprites/skill_u.png', // 鸦杀技能
    hit: 'sprites/hit.png',        // 受击
    skill_o: 'sprites/skill_o.png', // 奥义
    skill_i: 'sprites/skill_i.png', // 龙舌突刺
    attack: 'sprites/attack.png'   // 挥舞攻击
};

// ============== 工具函数 ==============
function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h || r2.y + r2.h < r1.y);
}

function lerp(a, b, t) {
    return a + (b - a) * t;
}

// ============== 粒子系统 ==============
class Particle {
    constructor(x, y, color, options = {}) {
        this.x = x + (Math.random() - 0.5) * (options.spread || 30);
        this.y = y + (Math.random() - 0.5) * (options.spread || 30);
        this.vx = (Math.random() - 0.5) * (options.speed || 8);
        this.vy = (Math.random() - 0.5) * (options.speed || 8) - (options.upward || 0);
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
        this.size = Math.random() * (options.maxSize || 8) + (options.minSize || 3);
        this.color = color;
        this.gravity = options.gravity || 0.1;
        this.shape = options.shape || 'rect'; // 'rect', 'circle', 'ink'
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.life -= this.decay;
        this.size *= 0.96;
        this.vx *= 0.98;
    }

    render(ctx) {
        ctx.globalAlpha = this.life * 0.8;
        ctx.fillStyle = this.color;
        
        if (this.shape === 'ink') {
            // 墨水滴形状
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, this.size, this.size * 1.5, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.shape === 'circle') {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        }
        ctx.globalAlpha = 1.0;
    }
}

// ============== 投射物 ==============
class Projectile {
    constructor(game, x, y, vx, vy, owner, damage = 10) {
        this.game = game;
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.w = 25;
        this.h = 15;
        this.owner = owner;
        this.active = true;
        this.damage = damage;
        this.rotation = 0;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += 0.2;
        
        // 拖尾粒子
        if (Math.random() < 0.6) {
            this.game.particles.push(new Particle(this.x, this.y, '#1a1a1a', {
                spread: 5, speed: 2, maxSize: 6, minSize: 2, shape: 'ink'
            }));
        }
    }

    getHitbox() {
        return { x: this.x - this.w/2, y: this.y - this.h/2, w: this.w, h: this.h };
    }

    render(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // 乌鸦形状的墨弹
        ctx.fillStyle = '#0a0a0a';
        ctx.beginPath();
        // 身体
        ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        // 翅膀
        ctx.beginPath();
        ctx.moveTo(-5, -3);
        ctx.quadraticCurveTo(-15, -12, -8, -5);
        ctx.moveTo(-5, 3);
        ctx.quadraticCurveTo(-15, 12, -8, 5);
        ctx.fill();
        // 喙
        ctx.beginPath();
        ctx.moveTo(12, 0);
        ctx.lineTo(18, -2);
        ctx.lineTo(18, 2);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }
}

// ============== 实体基类 ==============
class Entity {
    constructor(game, x, y, w, h) {
        this.game = game;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.vx = 0;
        this.vy = 0;
        this.facing = 1;
        
        this.maxHp = 100;
        this.hp = this.maxHp;
        
        this.state = STATE.IDLE;
        this.stateTimer = 0;
        this.frameCount = 0;
        
        this.isGrounded = false;
        this.activeHitbox = null;
        this.hitThisAttack = false;
        
        this.comboCount = 0;
        this.comboTimer = 0;
    }

    updatePhysics() {
        // 重力
        if (!this.isGrounded) {
            this.vy += CONFIG.GRAVITY;
        }
        
        this.x += this.vx;
        this.y += this.vy;

        // 地面碰撞
        if (this.y + this.h >= CONFIG.GROUND_Y) {
            this.y = CONFIG.GROUND_Y - this.h;
            this.vy = 0;
            this.isGrounded = true;
        } else {
            this.isGrounded = false;
        }

        // 边界
        if (this.x < 0) this.x = 0;
        if (this.x + this.w > CONFIG.CANVAS_WIDTH) this.x = CONFIG.CANVAS_WIDTH - this.w;

        // 地面摩擦
        if (this.isGrounded && this.state !== STATE.DASH) {
            this.vx *= CONFIG.FRICTION;
            if (Math.abs(this.vx) < 0.5) this.vx = 0;
        }
    }

    getHurtbox() {
        return { x: this.x, y: this.y, w: this.w, h: this.h };
    }

    takeDamage(amount, knockbackDir, knockbackForce = 6) {
        if (this.state === STATE.DEAD) return;
        
        this.hp -= amount;
        this.state = STATE.HIT;
        this.stateTimer = 18;
        this.vx = knockbackDir * knockbackForce;
        this.vy = -4;
        this.activeHitbox = null;
        
        // 连击计数
        const attacker = this === this.game.player ? this.game.enemy : this.game.player;
        attacker.comboCount++;
        attacker.comboTimer = 120;
        
        if (this.hp <= 0) {
            this.hp = 0;
            this.state = STATE.DEAD;
            this.vx = knockbackDir * 4;
            this.vy = -8;
        }
    }
}

// ============== 玩家类 (玄月) ==============
class Player extends Entity {
    constructor(game, x, y) {
        super(game, x, y, 60, 90);
        this.maxHp = CONFIG.PLAYER.MAX_HP;
        this.hp = this.maxHp;
        this.maxMp = CONFIG.PLAYER.MAX_MP;
        this.mp = this.maxMp;
        
        this.jumpCount = 0;
        this.maxJumps = 2;
        this.comboIndex = 0;
        this.lastAttackTime = 0;
        this.dashCooldown = 0;
        
        // 精灵图
        this.sprites = {};
        this.currentSprite = null;
        this.spriteLoaded = false;
        
        // 动画帧
        this.animFrame = 0;
        this.animTimer = 0;
    }

    loadSprites(images) {
        this.sprites = images;
        this.spriteLoaded = true;
    }

    handleKeyDown(key) {
        if (this.state === STATE.HIT || this.state === STATE.DEAD) return;

        // 跳跃
        if (key === 'k') {
            if (this.jumpCount < this.maxJumps) {
                this.vy = CONFIG.PLAYER.JUMP_FORCE;
                this.jumpCount++;
                this.isGrounded = false;
                this.state = STATE.JUMP;
                this.game.spawnParticles(this.x + this.w/2, this.y + this.h, 8, '#888', { spread: 20, speed: 4, upward: 2 });
            }
        }

        // 瞬步
        if (key === 'l' && this.dashCooldown <= 0 && this.mp >= 10) {
            this.state = STATE.DASH;
            this.stateTimer = CONFIG.PLAYER.DASH_DURATION;
            this.vx = this.facing * CONFIG.PLAYER.DASH_SPEED;
            this.vy = 0;
            this.mp -= 10;
            this.dashCooldown = CONFIG.PLAYER.DASH_COOLDOWN;
        }

        // 普攻
        if (key === 'j') {
            if (this.state !== STATE.ATTACK || this.frameCount > 12) {
                const now = Date.now();
                if (now - this.lastAttackTime < 400 && this.comboIndex < 3) {
                    this.comboIndex++;
                } else {
                    this.comboIndex = 1;
                }
                this.startAttack(this.comboIndex);
            }
        }

        // 技能 U: 鸦杀
        if (key === 'u' && this.mp >= 20 && ![STATE.ATTACK, STATE.SKILL_U, STATE.SKILL_I, STATE.SKILL_O].includes(this.state)) {
            this.useSkill('U');
        }

        // 技能 I: 龙舌
        if (key === 'i' && this.mp >= 30 && ![STATE.ATTACK, STATE.SKILL_U, STATE.SKILL_I, STATE.SKILL_O].includes(this.state)) {
            this.useSkill('I');
        }

        // 奥义 O: 崩界
        if (key === 'o' && this.mp >= 50 && ![STATE.ATTACK, STATE.SKILL_U, STATE.SKILL_I, STATE.SKILL_O].includes(this.state)) {
            this.useSkill('O');
        }
    }

    startAttack(index) {
        this.state = STATE.ATTACK;
        this.stateTimer = 22;
        this.frameCount = 0;
        this.lastAttackTime = Date.now();
        this.hitThisAttack = false;
        
        const attacks = {
            1: { damage: 6, rangeW: 70, rangeH: 60, xOff: 25, hitstop: 4, shake: 2, knockback: 4 },
            2: { damage: 8, rangeW: 75, rangeH: 65, xOff: 30, hitstop: 5, shake: 3, knockback: 5 },
            3: { damage: 15, rangeW: 90, rangeH: 80, xOff: 35, hitstop: 10, shake: 8, knockback: 10 }
        };
        this.attackData = attacks[index];
        
        // 攻击时小位移
        this.vx = this.facing * 3;
    }

    useSkill(key) {
        this.frameCount = 0;
        this.hitThisAttack = false;
        
        if (key === 'U') {
            this.state = STATE.SKILL_U;
            this.stateTimer = 30;
            this.mp -= 20;
        } else if (key === 'I') {
            this.state = STATE.SKILL_I;
            this.stateTimer = 35;
            this.mp -= 30;
        } else if (key === 'O') {
            this.state = STATE.SKILL_O;
            this.stateTimer = 80;
            this.mp -= 50;
            this.game.triggerUltimate();
        }
    }

    update(keys) {
        this.frameCount++;
        if (this.dashCooldown > 0) this.dashCooldown--;
        if (this.mp < this.maxMp) this.mp += CONFIG.PLAYER.MP_REGEN;
        if (this.mp > this.maxMp) this.mp = this.maxMp;
        if (this.isGrounded) this.jumpCount = 0;
        
        // 连击计时
        if (this.comboTimer > 0) {
            this.comboTimer--;
            if (this.comboTimer <= 0) this.comboCount = 0;
        }

        // 动画计时器
        this.animTimer++;
        if (this.animTimer > 8) {
            this.animTimer = 0;
            this.animFrame++;
        }

        switch (this.state) {
            case STATE.IDLE:
            case STATE.RUN:
            case STATE.JUMP:
                if (keys['a']) {
                    this.vx = -CONFIG.PLAYER.SPEED;
                    this.facing = -1;
                    if (this.isGrounded) this.state = STATE.RUN;
                } else if (keys['d']) {
                    this.vx = CONFIG.PLAYER.SPEED;
                    this.facing = 1;
                    if (this.isGrounded) this.state = STATE.RUN;
                } else {
                    if (this.isGrounded) this.state = STATE.IDLE;
                }
                if (!this.isGrounded) this.state = STATE.JUMP;
                break;

            case STATE.DASH:
                this.stateTimer--;
                // 残影
                if (this.stateTimer % 2 === 0) {
                    this.game.spawnParticles(this.x + this.w/2, this.y + this.h/2, 3, '#333', { spread: 10, speed: 1 });
                }
                if (this.stateTimer <= 0) {
                    this.vx *= 0.3;
                    this.state = STATE.IDLE;
                }
                break;

            case STATE.ATTACK:
                this.vx *= 0.85;
                this.stateTimer--;
                
                // 攻击判定窗口
                if (this.stateTimer > 6 && this.stateTimer < 16 && !this.hitThisAttack) {
                    const hbX = this.facing === 1 
                        ? this.x + this.w/2 + this.attackData.xOff 
                        : this.x + this.w/2 - this.attackData.xOff - this.attackData.rangeW;
                    this.activeHitbox = {
                        x: hbX,
                        y: this.y + 15,
                        w: this.attackData.rangeW,
                        h: this.attackData.rangeH,
                        damage: this.attackData.damage,
                        hitstop: this.attackData.hitstop,
                        shake: this.attackData.shake,
                        knockback: this.attackData.knockback
                    };
                } else {
                    this.activeHitbox = null;
                }

                if (this.stateTimer <= 0) {
                    this.state = STATE.IDLE;
                    this.activeHitbox = null;
                }
                break;

            case STATE.SKILL_U:
                this.vx = 0;
                this.stateTimer--;
                
                // 发射墨弹
                if (this.stateTimer === 22) {
                    for (let i = 0; i < 3; i++) {
                        const vy = (i - 1) * 2;
                        const proj = new Projectile(
                            this.game,
                            this.x + this.w/2 + this.facing * 30,
                            this.y + 30,
                            this.facing * 14,
                            vy,
                            this,
                            12
                        );
                        this.game.projectiles.push(proj);
                    }
                    this.game.spawnParticles(this.x + this.w/2, this.y + 30, 15, '#1a1a1a', { spread: 20, speed: 6, shape: 'ink' });
                }

                if (this.stateTimer <= 0) this.state = STATE.IDLE;
                break;

            case STATE.SKILL_I:
                this.stateTimer--;
                
                // 突刺判定
                if (this.stateTimer > 10 && this.stateTimer < 28 && !this.hitThisAttack) {
                    const hbX = this.facing === 1 ? this.x + this.w/2 : this.x + this.w/2 - 220;
                    this.activeHitbox = {
                        x: hbX,
                        y: this.y + 30,
                        w: 220,
                        h: 40,
                        damage: 22,
                        hitstop: 12,
                        shake: 10,
                        knockback: 12
                    };
                    this.vx = this.facing * 8;
                    
                    // 突刺粒子
                    if (this.frameCount % 2 === 0) {
                        this.game.spawnParticles(this.x + this.w/2, this.y + this.h/2, 2, '#1a1a1a', { spread: 15, speed: 3 });
                    }
                } else {
                    this.activeHitbox = null;
                    this.vx *= 0.9;
                }

                if (this.stateTimer <= 0) {
                    this.state = STATE.IDLE;
                    this.activeHitbox = null;
                }
                break;

            case STATE.SKILL_O:
                this.vx = 0;
                this.stateTimer--;
                
                // 奥义伤害帧
                if (this.stateTimer === 40 && !this.hitThisAttack) {
                    this.game.enemy.takeDamage(45, this.facing, 15);
                    this.hitThisAttack = true;
                    this.game.hitStop = 25;
                    this.game.spawnParticles(this.game.enemy.x + this.game.enemy.w/2, this.game.enemy.y + this.game.enemy.h/2, 60, '#1a1a1a', { spread: 50, speed: 12, shape: 'ink' });
                }

                if (this.stateTimer <= 0) this.state = STATE.IDLE;
                break;

            case STATE.HIT:
                this.stateTimer--;
                if (this.stateTimer <= 0) this.state = STATE.IDLE;
                break;

            case STATE.DEAD:
                this.vx *= 0.95;
                break;
        }

        this.updatePhysics();
    }

    render(ctx) {
        ctx.save();
        
        const centerX = this.x + this.w / 2;
        const centerY = this.y + this.h / 2;
        
        ctx.translate(centerX, centerY);
        ctx.scale(this.facing, 1);
        
        // 阴影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(0, this.h/2 - 5, this.w/2 + 10, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        // 选择正确的精灵图
        let sprite = null;
        let spriteKey = 'idle';
        
        switch (this.state) {
            case STATE.RUN:
            case STATE.DASH:
                spriteKey = 'run';
                break;
            case STATE.ATTACK:
                spriteKey = 'attack';
                break;
            case STATE.SKILL_U:
                spriteKey = 'skill_u';
                break;
            case STATE.SKILL_I:
                spriteKey = 'skill_i';
                break;
            case STATE.SKILL_O:
                spriteKey = 'skill_o';
                break;
            case STATE.HIT:
                spriteKey = 'hit';
                break;
            default:
                spriteKey = 'idle';
        }

        sprite = this.sprites[spriteKey];

        // 受击闪白效果
        if (this.state === STATE.HIT && this.stateTimer % 4 < 2) {
            ctx.filter = 'brightness(3)';
        }
        
        // 冲刺半透明
        if (this.state === STATE.DASH) {
            ctx.globalAlpha = 0.6;
        }

        // 绘制精灵图
        if (sprite && sprite.complete && sprite.naturalWidth > 0) {
            const scale = 1.8; // 缩放比例
            const sw = sprite.naturalWidth * scale;
            const sh = sprite.naturalHeight * scale;
            ctx.drawImage(sprite, -sw/2, -sh/2 + 10, sw, sh);
        } else {
            // 后备：绘制简单的角色
            this.drawFallbackCharacter(ctx);
        }

        ctx.filter = 'none';
        ctx.globalAlpha = 1;

        // 技能 I 的长毛笔特效
        if (this.state === STATE.SKILL_I && this.activeHitbox) {
            ctx.fillStyle = '#2d2d2d';
            ctx.fillRect(30, -5, 200, 15);
            // 笔锋
            ctx.beginPath();
            ctx.moveTo(230, -8);
            ctx.lineTo(260, 2);
            ctx.lineTo(230, 12);
            ctx.closePath();
            ctx.fillStyle = '#1a1a1a';
            ctx.fill();
        }

        ctx.restore();

        // Debug: 显示攻击判定框
        // if (this.activeHitbox) {
        //     ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        //     ctx.lineWidth = 2;
        //     ctx.strokeRect(this.activeHitbox.x, this.activeHitbox.y, this.activeHitbox.w, this.activeHitbox.h);
        // }
    }

    drawFallbackCharacter(ctx) {
        // 身体
        ctx.fillStyle = this.state === STATE.HIT ? '#fff' : '#1a1a1a';
        ctx.fillRect(-this.w/2 + 10, -this.h/2 + 10, this.w - 20, this.h - 20);
        
        // 披风
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(-5, -this.h/2 + 20);
        ctx.quadraticCurveTo(-30 - Math.sin(this.frameCount * 0.15) * 8, this.h/2 - 20, -20, this.h/2);
        ctx.lineTo(-5, this.h/2 - 10);
        ctx.fill();
        
        // 毛笔
        ctx.save();
        let brushAngle = -Math.PI / 4;
        if (this.state === STATE.ATTACK) {
            const progress = (22 - this.stateTimer) / 22;
            brushAngle = -Math.PI/2 + progress * Math.PI * 1.2;
        }
        ctx.rotate(brushAngle);
        ctx.fillStyle = '#4a3728';
        ctx.fillRect(-4, -50, 8, 80);
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(-6, 30);
        ctx.quadraticCurveTo(0, 55, 6, 30);
        ctx.fill();
        ctx.restore();
        
        // 眼睛
        ctx.fillStyle = '#fff';
        ctx.fillRect(8, -this.h/4, 8, 5);
    }
}

// ============== 敌人类 (里奥) ==============
class Enemy extends Entity {
    constructor(game, x, y) {
        super(game, x, y, 50, 80);
        this.maxHp = CONFIG.ENEMY.MAX_HP;
        this.hp = this.maxHp;
        this.aiTimer = 0;
        this.aiState = 'idle';
    }

    update() {
        this.frameCount++;
        
        // 连击计时
        if (this.comboTimer > 0) {
            this.comboTimer--;
            if (this.comboTimer <= 0) this.comboCount = 0;
        }

        if (this.state === STATE.HIT) {
            this.stateTimer--;
            if (this.stateTimer <= 0) this.state = STATE.IDLE;
            this.updatePhysics();
            return;
        }

        if (this.state === STATE.DEAD) {
            this.vx *= 0.95;
            this.updatePhysics();
            return;
        }

        // AI 逻辑
        this.aiTimer++;
        const player = this.game.player;
        const dist = player.x - this.x;
        const absDist = Math.abs(dist);
        
        this.facing = dist > 0 ? 1 : -1;

        // 攻击状态
        if (this.state === STATE.ATTACK) {
            this.stateTimer--;
            if (this.stateTimer > 12 && this.stateTimer < 22 && !this.hitThisAttack) {
                const hbX = this.facing === 1 ? this.x + this.w/2 : this.x + this.w/2 - 60;
                this.activeHitbox = {
                    x: hbX,
                    y: this.y + 20,
                    w: 60,
                    h: 50,
                    damage: 10,
                    hitstop: 6,
                    shake: 4,
                    knockback: 6
                };
            } else {
                this.activeHitbox = null;
            }
            if (this.stateTimer <= 0) {
                this.state = STATE.IDLE;
                this.activeHitbox = null;
            }
        } else {
            // 移动和攻击决策
            if (absDist < CONFIG.ENEMY.ATTACK_RANGE) {
                this.vx = 0;
                if (this.aiTimer > 40 && player.state !== STATE.DEAD) {
                    this.state = STATE.ATTACK;
                    this.stateTimer = 30;
                    this.hitThisAttack = false;
                    this.aiTimer = 0;
                }
            } else if (absDist < CONFIG.ENEMY.AGGRO_RANGE) {
                this.vx = this.facing * CONFIG.ENEMY.SPEED;
                this.state = STATE.RUN;
            } else {
                this.vx *= 0.9;
                this.state = STATE.IDLE;
            }
        }

        this.updatePhysics();
    }

    render(ctx) {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        ctx.scale(this.facing, 1);

        // 阴影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(0, this.h/2 - 5, this.w/2 + 5, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        // 受击闪白
        if (this.state === STATE.HIT && this.stateTimer % 4 < 2) {
            ctx.fillStyle = '#fff';
        } else {
            ctx.fillStyle = '#8b1a1a';
        }

        // 身体
        ctx.fillRect(-this.w/2 + 5, -this.h/2 + 5, this.w - 10, this.h - 10);
        
        // 装饰条纹
        ctx.fillStyle = '#5c1010';
        ctx.fillRect(-this.w/2 + 8, -this.h/4, this.w - 16, 8);
        ctx.fillRect(-this.w/2 + 8, this.h/8, this.w - 16, 8);

        // 眼睛
        ctx.fillStyle = '#ffcc00';
        ctx.fillRect(8, -this.h/4 - 5, 10, 6);
        ctx.fillStyle = '#000';
        ctx.fillRect(12, -this.h/4 - 4, 4, 4);

        // 拳头（攻击时）
        if (this.state === STATE.ATTACK && this.stateTimer > 10 && this.stateTimer < 24) {
            ctx.fillStyle = '#5c1010';
            ctx.fillRect(this.w/2, -5, 25, 20);
        }

        ctx.restore();
    }
}

// ============== 游戏主类 ==============
class Game {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = CONFIG.CANVAS_WIDTH;
        this.height = CONFIG.CANVAS_HEIGHT;
        
        this.lastTime = 0;
        this.hitStop = 0;
        this.shake = 0;
        this.darkness = 0;
        this.ultimateFlash = 0;
        
        this.particles = [];
        this.projectiles = [];
        
        this.player = new Player(this, 150, CONFIG.GROUND_Y - 90);
        this.enemy = new Enemy(this, 700, CONFIG.GROUND_Y - 80);
        
        this.keys = {};
        this.initInput();
        
        this.ui = {
            p1Hp: document.getElementById('p1-hp'),
            p1Mp: document.getElementById('p1-mp'),
            p2Hp: document.getElementById('p2-hp'),
            comboP1: document.getElementById('combo-p1'),
            comboP2: document.getElementById('combo-p2'),
        };
        
        // 背景元素
        this.bgElements = this.generateBackground();
        
        // 加载精灵图
        this.loadSprites();
    }

    loadSprites() {
        const loadingEl = document.getElementById('loading');
        
        // 创建图片对象 - 这里我们使用本地文件路径
        // 用户需要将图片放在 sprites 文件夹中
        const spriteNames = ['idle', 'run', 'skill_u', 'hit', 'skill_o', 'skill_i', 'attack'];
        const sprites = {};
        let loaded = 0;
        
        spriteNames.forEach((name, index) => {
            const img = new Image();
            img.onload = () => {
                loaded++;
                if (loaded === spriteNames.length) {
                    loadingEl.style.display = 'none';
                    this.player.loadSprites(sprites);
                }
            };
            img.onerror = () => {
                loaded++;
                console.warn(`Failed to load sprite: ${name}`);
                if (loaded === spriteNames.length) {
                    loadingEl.style.display = 'none';
                    this.player.loadSprites(sprites);
                }
            };
            // 尝试加载本地图片
            img.src = `images/${name}.png`;
            sprites[name] = img;
        });
        
        // 超时后隐藏加载提示
        setTimeout(() => {
            loadingEl.style.display = 'none';
        }, 2000);
    }

    generateBackground() {
        const elements = [];
        // 远景山峦
        for (let i = 0; i < 5; i++) {
            elements.push({
                type: 'mountain',
                x: i * 250 - 100,
                y: CONFIG.GROUND_Y - 80 - Math.random() * 60,
                w: 300 + Math.random() * 100,
                h: 100 + Math.random() * 50,
                alpha: 0.15 + Math.random() * 0.1
            });
        }
        // 飘动的墨点
        for (let i = 0; i < 15; i++) {
            elements.push({
                type: 'inkdot',
                x: Math.random() * this.width,
                y: Math.random() * (CONFIG.GROUND_Y - 100),
                size: Math.random() * 4 + 1,
                speedX: (Math.random() - 0.5) * 0.3,
                speedY: (Math.random() - 0.5) * 0.2,
                alpha: Math.random() * 0.3 + 0.1
            });
        }
        return elements;
    }

    initInput() {
        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            if (!this.keys[key]) {
                this.keys[key] = true;
                if (!this.hitStop) {
                    this.player.handleKeyDown(key);
                }
            }
            e.preventDefault();
        });
        window.addEventListener('keyup', e => {
            this.keys[e.key.toLowerCase()] = false;
        });
    }

    triggerUltimate() {
        this.darkness = 1;
        this.ultimateFlash = 30;
        this.shake = 25;
    }

    spawnParticles(x, y, count, color, options = {}) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(x, y, color, options));
        }
    }

    start() {
        requestAnimationFrame(t => this.loop(t));
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;

        if (this.hitStop > 0) {
            this.hitStop--;
            this.render();
            requestAnimationFrame(t => this.loop(t));
            return;
        }

        this.update();
        this.render();
        requestAnimationFrame(t => this.loop(t));
    }

    update() {
        // 震动衰减
        if (this.shake > 0) this.shake *= 0.88;
        if (this.shake < 0.5) this.shake = 0;
        
        // 黑屏衰减
        if (this.darkness > 0) this.darkness -= 0.015;
        if (this.darkness < 0) this.darkness = 0;
        
        // 闪光衰减
        if (this.ultimateFlash > 0) this.ultimateFlash--;

        this.player.update(this.keys);
        this.enemy.update();
        
        // 粒子更新
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }

        // 投射物更新
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.update();
            
            const target = p.owner === this.player ? this.enemy : this.player;
            if (rectIntersect(p.getHitbox(), target.getHurtbox()) && target.state !== STATE.DEAD) {
                target.takeDamage(p.damage, p.vx > 0 ? 1 : -1, 8);
                this.spawnParticles(target.x + target.w/2, target.y + target.h/2, 12, '#c0392b', { spread: 25, speed: 6 });
                this.hitStop = 6;
                this.shake = 6;
                p.active = false;
            }

            if (!p.active || p.x < -50 || p.x > this.width + 50) {
                this.projectiles.splice(i, 1);
            }
        }

        // 近战判定
        this.checkMeleeHit(this.player, this.enemy);
        this.checkMeleeHit(this.enemy, this.player);

        // 背景动画
        this.bgElements.forEach(el => {
            if (el.type === 'inkdot') {
                el.x += el.speedX;
                el.y += el.speedY;
                if (el.x < 0) el.x = this.width;
                if (el.x > this.width) el.x = 0;
                if (el.y < 0) el.y = CONFIG.GROUND_Y - 100;
                if (el.y > CONFIG.GROUND_Y - 100) el.y = 0;
            }
        });

        this.updateUI();
    }

    checkMeleeHit(attacker, defender) {
        if (attacker.activeHitbox && !attacker.hitThisAttack && defender.state !== STATE.DEAD) {
            if (rectIntersect(attacker.activeHitbox, defender.getHurtbox())) {
                attacker.hitThisAttack = true;
                defender.takeDamage(
                    attacker.activeHitbox.damage,
                    attacker.facing,
                    attacker.activeHitbox.knockback || 6
                );
                
                this.hitStop = attacker.activeHitbox.hitstop || 8;
                this.shake = attacker.activeHitbox.shake || 5;
                
                const color = attacker === this.player ? '#1a1a1a' : '#c0392b';
                this.spawnParticles(defender.x + defender.w/2, defender.y + defender.h/2, 18, color, { spread: 30, speed: 8, shape: 'ink' });
            }
        }
    }

    updateUI() {
        const p1HpPct = Math.max(0, (this.player.hp / this.player.maxHp) * 100);
        const p1MpPct = Math.max(0, (this.player.mp / this.player.maxMp) * 100);
        const p2HpPct = Math.max(0, (this.enemy.hp / this.enemy.maxHp) * 100);

        this.ui.p1Hp.style.width = `${p1HpPct}%`;
        this.ui.p1Mp.style.width = `${p1MpPct}%`;
        this.ui.p2Hp.style.width = `${p2HpPct}%`;

        // 连击显示
        if (this.player.comboCount > 1) {
            this.ui.comboP1.textContent = `${this.player.comboCount} HITS!`;
            this.ui.comboP1.classList.add('active');
        } else {
            this.ui.comboP1.classList.remove('active');
        }
        
        if (this.enemy.comboCount > 1) {
            this.ui.comboP2.textContent = `${this.enemy.comboCount} HITS!`;
            this.ui.comboP2.classList.add('active');
        } else {
            this.ui.comboP2.classList.remove('active');
        }
    }

    render() {
        const ctx = this.ctx;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        
        // 清空画布
        ctx.fillStyle = '#d4d4c4';
        ctx.fillRect(0, 0, this.width, this.height);

        // 应用震动
        const shakeX = (Math.random() - 0.5) * this.shake * 2;
        const shakeY = (Math.random() - 0.5) * this.shake * 2;
        ctx.translate(shakeX, shakeY);

        // 绘制背景
        this.renderBackground(ctx);

        // 地面
        ctx.fillStyle = '#3d3d3d';
        ctx.fillRect(0, CONFIG.GROUND_Y, this.width, this.height - CONFIG.GROUND_Y);
        
        // 地面纹理
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 1;
        for (let i = 0; i < this.width; i += 40) {
            ctx.beginPath();
            ctx.moveTo(i, CONFIG.GROUND_Y);
            ctx.lineTo(i + 20, CONFIG.GROUND_Y + 60);
            ctx.stroke();
        }

        // 实体
        this.player.render(ctx);
        this.enemy.render(ctx);
        
        // 投射物
        this.projectiles.forEach(p => p.render(ctx));

        // 粒子
        this.particles.forEach(p => p.render(ctx));

        // 奥义特效
        if (this.ultimateFlash > 0) {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            if (this.ultimateFlash > 20) {
                ctx.fillStyle = `rgba(255, 255, 255, ${(this.ultimateFlash - 20) / 10})`;
                ctx.fillRect(0, 0, this.width, this.height);
            }
        }

        // 黑屏遮罩
        if (this.darkness > 0) {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = `rgba(0, 0, 0, ${this.darkness})`;
            ctx.fillRect(0, 0, this.width, this.height);
            
            // 奥义文字
            if (this.darkness > 0.5) {
                ctx.fillStyle = `rgba(255, 255, 255, ${(this.darkness - 0.5) * 2})`;
                ctx.font = 'bold 48px "Microsoft YaHei", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('墨皇·崩界', this.width / 2, this.height / 2);
            }
        }
    }

    renderBackground(ctx) {
        // 水墨风格背景
        ctx.fillStyle = '#c8c8b8';
        ctx.font = '120px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 0.08;
        ctx.fillText('沧浪', this.width / 2, this.height / 2 - 50);
        ctx.globalAlpha = 1;

        // 远景山峦
        this.bgElements.forEach(el => {
            if (el.type === 'mountain') {
                ctx.globalAlpha = el.alpha;
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(el.x, CONFIG.GROUND_Y);
                ctx.quadraticCurveTo(el.x + el.w / 2, el.y, el.x + el.w, CONFIG.GROUND_Y);
                ctx.fill();
            }
        });
        ctx.globalAlpha = 1;

        // 墨点
        ctx.fillStyle = '#333';
        this.bgElements.forEach(el => {
            if (el.type === 'inkdot') {
                ctx.globalAlpha = el.alpha;
                ctx.beginPath();
                ctx.arc(el.x, el.y, el.size, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        ctx.globalAlpha = 1;
    }
}

// ============== 启动游戏 ==============
window.onload = () => {
    const canvas = document.getElementById('gameCanvas');
    const game = new Game(canvas);
    game.start();
};
</script>
</body>
</html>

